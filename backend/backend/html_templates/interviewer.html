<!DOCTYPE html>
<html lang="en">
<head>
    <title>Audio Stream</title>
</head>
<body>
    <button id="startButton">Start Audio</button>
    <script>
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const audioQueue = [];
        let isPlaying = false;

        const startButton = document.getElementById('startButton');

        startButton.addEventListener('click', async () => {
            if (audioContext.state === 'suspended') {
                await audioContext.resume();
            }

            const ws = new WebSocket(`ws://${location.host}/<---WEBSOCKET_ENDPOINT--->/`);
            ws.binaryType = 'arraybuffer';
            ws.onmessage = async (event) => {
                audioQueue.push(event.data);
                if (!isPlaying) {
                    playAudioQueue();
                }
            };
        });

        let bufferThreshold = 1; // Number of chunks to buffer before playing
        let isBuffering = true; // New flag to manage the buffering state

        async function playAudioQueue() {
            // Start playing if we've reached the buffer threshold or if we're already playing and more data is available
            if ((isBuffering && audioQueue.length >= bufferThreshold) || (!isBuffering && audioQueue.length > 0)) {
                if (isBuffering) {
                    isBuffering = false; // Stop buffering once we start playing
                }
                while (audioQueue.length > 0) {
                    isPlaying = true;
                    const audioData = audioQueue.shift(); // Get the first chunk in the queue
                    await playAudioChunk(audioData);
                }
                isPlaying = false; // Set to false when the queue is empty
            }
        }


        let nextTime = 0; // Tracks when the next audio chunk should start.

        async function playAudioChunk(audioData) {
            try {
                const decodedData = await audioContext.decodeAudioData(audioData.slice(0));
                const source = audioContext.createBufferSource();
                source.buffer = decodedData;
                source.connect(audioContext.destination);

                // Schedule playback to ensure smooth transition between chunks
                const currentTime = audioContext.currentTime;
                const startOffset = nextTime > currentTime ? nextTime : currentTime;
                source.start(startOffset);
                nextTime = startOffset + source.buffer.duration; // Schedule the next chunk

                // Return a promise that resolves when the audio finishes playing
                return new Promise(resolve => source.onended = resolve);
            } catch (e) {
                console.error('Error decoding audio data:', e);
            }
        }

        ws.onmessage = async (event) => {
            audioQueue.push(event.data);
            if (!isPlaying) {
                playAudioQueue(); // Try to play the queue if not already playing
            }
        };
    </script>
</body>
</html>